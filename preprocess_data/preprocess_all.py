# -*- coding: utf-8 -*-
"""preprocess_all.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aQga05QIl4reaTmnbDUJwVxgOZ4n7YEe
"""

# creates a pickle of waveforms and images of frames of videos with associated labels

from google.colab import drive
drive.mount('/content/gdrive', force_remount=False)

# Commented out IPython magic to ensure Python compatibility.
!pip install torch>=1.2.0
!pip install torchaudio
# %matplotlib inline

import numpy as np
import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
from torchvision import datasets, transforms, io
from torch.utils.data import Dataset
import torchaudio
import pandas as pd
import os
from google.colab import files
import pickle
import matplotlib.pyplot as plt
import math
from PIL import Image
from google.colab.patches import cv2_imshow
import sys
import argparse
import cv2

device = torch.device("cuda" if torch.cuda.is_available() else "cpu") # see whether gpu can be used
print(device)

# getting the frames of images
def extractImages(pathIn, pathOut):
    vidcap = cv2.VideoCapture(pathIn)
    frames_skipped = 3 # our videos are 30 fps, so want to use 5 (6 fps) for the first 4 images
    success,image = vidcap.read()
    count = 0
    i = 0
    success = True
    while success and count < 4:
      success,image = vidcap.read()
      if i > frames_skipped - 1:
        # print ('Read a new frame: ', success)
        if success:
          cv2.imwrite( pathOut + "/frame%d.jpg" % count, image)     # save frame as JPEG file
          count += 1
          i = 0
          continue
      i += 1
    return count

aud_list = [] # initialize a list for waveforms to be added
frames_df = pd.DataFrame(columns = ['frame0', 'frame1', 'frame2', 'frame3']) # initialize a frames dataframe
# iterate through the folder structure to convert .mp4 files to .wav, then convert to waveform and also extract frames
for obj in range(12):
    for mat in range(5):
        for root, dirs, files in os.walk("/content/gdrive/My Drive/fall/{}/{}/".format(obj,mat), topdown=False): # change directory as necessary
            for name in files:
                full_file_name = os.path.join(root, name) # full name of the file including root
                if full_file_name.endswith("Camera_1.mp4"): # we only care about this file in each folder
                    clip = mp.VideoFileClip(r"{}".format(full_file_name))
                    clip.audio.write_audiofile(r"{}/Camera_1.wav".format(root)) # convert .mp4 to .wav
                    waveform, sample_rate = torchaudio.load("{}/Camera_1.wav".format(root)) # convert .wav to waveform
                    aud_list.append(waveform[0])
                    count = extractImages(full_file_name, root)
                    frames = []
                    # get frames
                    for i in range(4):
                      if i < count:
                        frames.append(os.path.join(root, "frame{}.jpg".format(i)))
                      else:
                        frames.append(np.nan)
                    # print(frames)
                    frame_series = pd.Series(frames, index = frames_df.columns)
                    frames_df = frames_df.append(frame_series, ignore_index=True) # add frames to initialized dataframe

# since the videos vary in length, we pad the waveforms to match the longest video
aud_list_padded = [] # initialize a list of padded waveforms
for i in range(len(aud_list)):
    diff = 311787 - len(aud_list[i]) # 311787 is the length of the longest file; compute the difference between current file and longest file
    pad = torch.nn.functional.pad(aud_list[i], (math.floor(diff/2),math.ceil(diff/2)), mode='constant', value=0) # pad with appropriate number of zeros
    aud_list_padded.append(pad)

phys101_df = pd.read_csv('/content/gdrive/My Drive/Phys101.csv', sep=',', header=None) # read off the labels from csv
phys101_df.fillna(0) # turn any NaN into 0
phys101_df['Sound'] = aud_list_padded # add a 'Sound' column with waveforms to dataframe
phys101_merged_df = pd.concat([phys101_df, frames_df], axis=1, sort=False)
phys101_merged_df.to_pickle("/content/gdrive/My Drive/phys101merged.pkl") # save to pickle for future use

# visualize one image
img = cv2.imread(np.asarray(phys101_df_shuffled['frame0'])[0])
cv2_imshow(img)